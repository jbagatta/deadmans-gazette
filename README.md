# Deadman's Gazette

A secure and resilient software-implemented dead man's switch, using the drand network for time-lock encryption, and multi-key (zero-access) encryption schemes for cancelability. Designed to withstand coordinated attack from state-level actors.

*NOTE: The code provided in this repository is a proof-of-concept ONLY. It has not been audited by security professionals, and while I've done my best, I am quite frankly **not** good enough at this to be the solely-responsible security engineer for a project like this in my spare time. **PLEASE DO NOT USE THIS CODE AS-IS**.*

## Overview

The dead man's switch is created using a multi-key encryption scheme to secure the payload, and then time-locking the controlling password. By allowing the originator to securely delete the intermediary in this chain (a Data Encryption Key (DEK) encrypted using the Key Encryption Key (KEK) generated by the time-locked password), the dead man's switch can be canceled or reset before the end of the time-lock window.

#### Time-Lock Encryption

Time-lock encryption is provided by the tlock library, which makes use of the [drand network](https://docs.drand.love/docs/timelock-encryption/), a distributed randomness beacon maintained by [The League of Entropy](https://www.drand.love/loe). 

There is some *fascinating* math behind this, but the poorly-explained layman's tldr is this: 

The network makes available a public key with which to encrypt data. This key, and its associated private key, are associated with a future "round number", which maps to a specific point in time. The network's randomness beacon as of this round number, and thus the value of the associated private key, are both predictable in advance *without the private key being explicitly computable before the network releases the round's randomness*. The network generates the private key (and prevents early release of it) using consensus, so as long as the majority of nodes in the network are trustworthy, the time-lock is secure. As of the time of this writing (Spring 2025), that node network is considered trustable and non-malicious. 

Time-lock encryption is a **hard** problem, and other strategies exist to provide it, such as proof-of-work and trusted third-parties. Each alternative has it's own set of risks and drawbacks, but roughly speaking, each would work within this system in place of drand (which is not without its own risks, detailed below).

#### Cancellability

Cancellability is achieved by establishing a breakable chain of decryptions via a multi-key encryption strategy, such that access to the final payload (using a Data Encryption Key, or DEK) is granted only by access to an intermediary Key Encryption Key (KEK), whose access in turn is ultimately provisioned by the drand time-lock. A dead man's switch established in this way can be securely canceled by deleting the KEK-encrypted DEK before its access is granted by the release of the time-locked password. If no action is taken by the originator, however, the time-lock will release the password, thus granting access to the password-generated KEK, which in turn enables decryption of the DEK and finally the encrypted payload.

To provide an analogy, imagine you've locked an important document in a lockbox at a bank, and mailed your friend the key with instructions to open it unless they hear otherwise from you. This is a traditional IRL (non-software-based) dead man's switch. Your friend will be able to open the box and view the document as soon as they receive the key. You (or an adversary) can only stop this process by removing the document before the key arrives.

Now assume that, for whatever reason, someone at the bank (or more likely, someone with subpoena power over that bank) wants to destroy, or otherwise prevent access to, the lockbox. And they're willing to do whatever is in their power to seize *any* such lockbox you try to establish. Your best bet to ensure eventual access is to create redundant lockboxes, enough of them so that the adversary can't realistically destroy them all. Easy enough!

However, you then need to tell your friend about all the lockbox locations. And maybe your friend is not as trustworth as you initially thought -- or better yet, maybe your friend is the first person they'd suspect, so in stead you choose a stranger who, while untrustworth, would not be predictable by your adversary. You obviously can't maintain control over all the lockboxes, and if you don't tell the friend/stranger (Keyholder) about all the locations (thus giving them time to seize a lockbox and simply wait for the key), then they can't enact the dead man's switch when they key arrives even if you wanted them to. 

So, how can you simultaneously:
1. Enable the keyholder to retrieve the document if you want them to, and
2. Prevent the keyholder from retrieving the document if you don't want them to?

This is where the breakable chain comes into play. Instead of mailing the key, you lock the key in a combination safe (that ONLY YOU maintain access to), and you mail the keyholder both the combination and the location of the safe. Nothing can stop them from opening that safe once they receive the letter, but at any time before then, you can simply open the safe and remove the key if you so choose. Now you can distribute as many lockboxes as you want, so that nobody can suppress all of them, and you can also guarantee the arrival of the combination to the keyholder, but you (and ONLY you) decide whether or not they ultimately retrieve the document. Eventual access to the safe no longer matters, because it doesn't provide access to the payload document *unless you want it to*. And -- importantly -- a complete lack of action on your part to disable it will leave the switch active, meaning an adversary cannot simply detain you to prevent release.

#### Deadman's Gazette

The system proposed here is an implementation of the safe from that analogy, along with scriptable instructions on how to set up, cancel, and defer a dead man's switch using the server. The server uses multi-key encryption and secure deletion to ensure that the originator of the dead man's switch retains complete control over if/when to release the payload, and to prevent anyone (even the host of the server itself) from accessing the payload without authorization.

Multi-key, zero-access encryption is standard practice for encrypted data storage, e.g. to allow a user to change their password without affecting the originally-encrypted data. In fact, the proposed dead man's switch design is effectively little more than a glorified password changing strategy, but with the additional complexity of the password being time-locked for public release. This requires additional care to ensure that the KEK-encrypted DEK is securely scrubbed if the switch is canceled or delayed by the originator, while maintaining resilient access to it if the switch instead remains active at expiry.

## Whitepaper

### Deadman's Gazette Server

The server itself is a very basic set of authenticated API around a secured data store:

#### API

- `INSERT ({passwordHash, encryptedDEK})`
    - `passwordHash` is the unique primary key and identifier
- `DELETE (passwordHash)`
    - securely deletes (i.e. renders unrecoverable) the stored `encryptedDEK` record
- `GET (passwordHash) -> encryptedDEK`
- Public HTTP: 
    - Serves a static page webapp to perform the client create/invalidate/delay actions described below 
    - Could also provide distribution of the public payload/packet data, directly to a blockchain or trusted drop site
- Need API to support salting as well

#### Data Store
- [SQLCipher](https://github.com/sqlcipher/sqlcipher)
    - Provides encrypted data storage and secure deletion
    - Embedded in the server itself

#### Deployment
- Containerized API+DB
- Modeled on the [SecureDrop security model](https://docs.securedrop.org/en/stable/)
- Deployed as a Tor Hidden Service
    - [Hardened against DoS attacks](https://community.torproject.org/onion-services/advanced/dos/)
    - [Following Best Practices](https://riseup.net/en/security/network-security/tor/onionservices-best-practices)

### Creating a Dead Man's Switch

0. Choose a payload with which to create a dead man's switch. 
    - **At the end of the chosen time-lock expiration, without further action from the originator, this payload will be made public**
1. Generate a strong encryption key for the payload 
    - This is the Data Encryption Key (DEK)
    - AES recommended
2. Generate a random plaintext password
    - This is the token that provides authorization for all future operations by the originator
    - **KEEP IT SECRET, KEEP IT SAFE**
3. Use the password from *Step 2* to generate a strong encryption key for the DEK
    - This is the Key Encryption Key (KEK)
    - Argon2 recommended, with salting
4. Use the KEK from *Step 3* to encrypt the DEK from *Step 1*
5. Deploy a Deadman's Gazette server (or use a **trusted** provider)
    - It's important that this server remain active for the duration of the expiration time length. It is therefore recommended that it be deployed secretly, resiliently, and securely, or that a trustworthy hosted service (i.e. one maintained by a reputable press organization) is used.
    - This should be deployed behind a Tor hidden service - make note of the server's onion route for *Step 8* below
6. Upload the hash of the plaintext password from *Step 2*, the encrypted DEK from *Step 4*, and the salt used to the Gazette server from *Step 5*
7. Use the DEK from *Step 1* to encrypt the payload from *Step 0*
    - This can never been decrypted without the DEK from *Step 1*, which itself can only be decrypted using the password that generated the KEK from *Step 2*
    - **At this point, nobody but the originator has access to the password, which means that until *Steps 8 and 9* below are completed, the payload can never be decrypted except by the originator**
    - 🚨🚨 **PROCEEDING WITH STEPS 8-9 BELOW WILL ACTIVATE THE DEAD MAN'S SWITCH** 🚨🚨
8. Time-lock encrypt the packet `{plaintextPassword(Step 2), serverOnionRoute(Step 5)}` using drand's tlock library
    - Map the desired time length to a drand round number and use that round's public key
9. Publish the encrypted payload from *Step 7* and the time-locked packet from *Step 8*, as well as the drand round number
    - Must be somewhere public and resilient (mirrored) so that it cannot be taken down, i.e. a publicly maintained drop site, or even a blockchain (if the payload is small enough)
    - It's important that the packet, payload and round number are all associated with each other visibly, to facilitate data recovery if/when desired

### What happens next?

The drand network ensures that the packet cannot be decrypted before the expiration time. At that time, without action from the originator, the dead man's switch will activate:

1. The decryption key for the packet will be generated and distributed by drand
2. Using that decryption key, a watcher of your dead man's switch can decrypt the publicly-available packet and retrieve the password as well as the onion route to the Deadman's Gazette hosting your data
3. That person can then retrieve the encrypted DEK from the server, and decrypt it using the password-generated KEK
4. Finally, they can use the resulting DEK to decrypt the original, publicly-available payload
5. And that's it! The switch has achieved the desired result, and the payload is now publicly released

### How to Deactivate/Reset the Switch

This system uses a breakable chain of multi-key decryptions to provide cancellation, which is otherwise not an inherent feature of drand time-locking. In order to prevent decryption at the end of the time-lock, the password must be rendered useless by securely deleting the encrypted DEK record from the Deadman's Gazette server (**NOTE: this requires trust in the server, see below***)

Once the record is deleted, the time-locked password is rendered useless, and the encrypted DEK no longer exists to be decrypted. The dead man's switch has been effectively disabled.

To instead delay/reset the switch, simply repeat part of the process above before deletion:

1. GET the encrypted DEK from the server using the password's hash
    - Deletion of the original `{passwordHash, encryptedDEK}` record can happen any time after *Step 1*
2. Use the password to generate the KEK and use it to decrypt the DEK
3. Generate a new random password and re-encrypt the DEK with the new password-generated KEK
4. Upload the new `{passwordHash, encryptedDEK}` to the server
5. Time-lock encrypt the new `{password, serverRoute}` packet using drand with the new expiry
6. Publish the new packet and round number and publicly associate them with the originally-uploaded encrypted payload

### Security Model

#### Drand Security Limitations

From the [drand documentation](https://docs.drand.love/docs/timelock-encryption/#%EF%B8%8F-security-assumptions):

> - **Malicious Nodes:** If a threshold number of malicious nodes join the network, they could generate all future random values and decrypt future timelock ciphertexts. Our quicknet network started with 18 organizations running 22 nodes, minimizing this risk.
> - **Quantum Resistance:** Our cryptography does not use quantum-resistant algorithms. If you encrypt something for 1000 years and a viable quantum computer emerges, it could decrypt it. Currently, no widespread quantum-resistant schemes exist for threshold identity-based encryption (IBE) cryptography.
> - **Network Shutdown:** If the League of Entropy shuts down, members would delete their keys. This means ciphertexts created after the network's cessation would be un-decryptable until quantum computers can break them.

#### Chain of Decryptions

The breakable chain of decryptions can be visualized:

```
[drandTimelock] -> [password] -> [KEK] -> [DEK] -> [PAYLOAD]
```

The payload maintains it's original encryption using the DEK at all times, and generating the KEK using the drand time-locked password cannot be prevented once set in motion. The indirection of using a secondary encryption to secure the DEK allows the time-lock to be reset or canceled at the will of the originator, simply by breaking the chain of decryptions (e.g. deleting the KEK-encrypted DEK) before the time-lock releases.

#### *Trust

It's important to understand what is being trusted, how it fits into this system, and how you can minimize or eliminate this trust as much as possible. 

The Gazette server uses SQLCipher as a database - this prevents any unauthorized person from reading data even if the DB files leaked, but it ALSO provides secure deletion to prevent even authorized persons (e.g. the Gazette hosts) from reading data once it has been deleted (see the [docs](https://discuss.zetetic.net/t/forensic-recovery-of-deleted-data/20)). 

This is important, because if a cancelled KEK-encrypted DEK is persisted without your knowledge, the payload CAN STILL be decrypted once the drand network publishes the decryption key for that KEK's password. The Deadman's Gazette server accepts a *salted hash* of the password as identity/auth, NOT the original password itself, meaning that the server itself does not know the password, and is no more capable of decrypting the DEK than anyone else until the time-lock decryption key is published by drand. Securely deleting the stored data BEFORE this happens ensures the chain of decryptions is broken irrevokably, and the payload cannot be decrypted, *even by the server that originally stored the data*. 

This server is provided open-source, in order to eliminate this trust boundary. You can be assured that the server deletes (and does not mirror/persist) the data as claimed simply by auditing the code to your satisfaction (or, of course, by trusting the security experts who do such things) and then deploying it yourself.

HOWEVER, USE OF THIS AS A HOSTED SERVICE COMES WITH AN IMPLICIT TRUST THAT THE DEPLOYED SERVER IS RUNNING THE AUDITED CODE, AND THUS THAT DATA IS BEING DELETED (AND NOT BEING MIRRORED/PERSISTED) IN THE WAY IT CLAIMS TO BE. This cannot be guaranteed using any hosted service, though presumably many would be trustworthy. **For this reason, if you have any concerns about the trustworthiness of a hosted service, or are handling payloads too sensitive to tolerate any level of risk, it is best to verify and deploy your own service.**

#### Other Considerations

The drand network is resilient against a certain number of malicious nodes (see the [docs](https://docs.drand.love/docs/security-model/)), which should keep the time-lock duration intact and prevent early decryption by curious, unauthorized parties. This is especially true for shorter time-lock windows. **I would strongly encourage any press outlets utilizing this system to participate in the drand network -- the more trusted nodes in the network, the more resilient it is against compromise.**

Publication of the payload and the packet should be done in such a way as to be resilient against coordinated effort to remove the data, ensuring it exists to be decrypted if/when desired. For small data payloads, distributed ledgers (blockchains) may be an effective storage.

Using onion services for the server provides effective security and anonymization, as well as a natural obfuscation of the server itself, thus precluding most likely attacks. A denial of service attack (e.g. using TorsHammer) could temporarily disable the server and thus prevent any action, but since the most likely goal of an adversary would be to prevent release of the payload, this attack would actually work against that interest. By denying the originator access to cancellation, a DoS attack (unless it is maintained indefinitely without mitigation/defense) serves only to prevent cancellation of the payload's release. Once the server becomes available again, the decryption chain will remain intact. 
