# Deadman's Gazette

A dead man's switch, implemented using the drand network for time-lock encryption, and multi-key (zero-access) encryption schemes for cancelability. Designed to withstand coordinated attack from state-level actors.

## Overview

The dead man's switch is created using a multi-key (zero-access) encryption scheme to secure the payload, and then time-locking the controlling password. By allowing the originator to delete or recreate the intermediary Key Encryption Key (KEK) in this chain (thus rendering the Data Ecryption Key (DEK) generated by the time-locked password useless), the dead man's switch can be canceled or reset before the password is released at the end of the time-lock window.

#### Time-Lock Encryption

Time-lock encryption is provided by the tlock library, which makes use of the [drand network](https://docs.drand.love/docs/timelock-encryption/), a distributed randomness beacon maintained by [The League of Entropy](https://www.drand.love/loe). 

As of the time of this writing (Spring 2025), that node network is considered trustable and non-malicious.

#### Cancellability

Cancellability is achieved by establishing a breakable chain of decryptions via a multi-key strategy, such that access to the final payload (using a Data Encryption Key, or DEK) is granted only by access to an intermediary Key Encryption Key (KEK), whose access in turn is ultimately provisioned by the drand time-lock. A dead man's switch established in this way is effectively canceled by scrubbing the KEK before its access is granted by the time-locked password being released. If no action is taken by the originator, however, the time-lock will publish the password, thus granting access to the KEK, which then grants access to the DEK and the payload.

To provide an analogy, imagine you've locked an important document in a lockbox at a bank, and mailed your friend the key with instructions to open it unless they hear otherwise from you. This is a traditional (non-software-based) dead man's switch. Your friend will be able to open the box and view the document as soon as they receive the key. You can only stop this process by removing the document before the key arrives.

Now assume that, for whatever reason, someone at the bank (or someone with subpoena power over that bank) wants to destroy, or otherwise prevent access to, the lockbox. Your best bet to ensure eventual access is to create redundant lockboxes, enough of them that nobody could destroy them all. Easy enough!

However, you then need to tell your friend about all the locations. And maybe your friend is maybe not as trustworth as you thought. You can't maintain control over all the copies, and if you don't tell your friend about all the locations (thus allowing them to seize one of them and simply wait for the key), then they can't enact the dead man's switch. 

So, how can you:
1. Enable your friend to retrieve the document if you want them to, and
2. Prevent your friend from retrieving the document if you don't want them to?

This is where the breakable chain comes into play. Instead of mailing your friend the key, you lock the key in a combination safe (that ONLY YOU maintain access to), and you mail your friend the combination. Nothing can stop them from opening that safe once they receive the combination, but if you choose, you can simply open it beforehand and remove the key. You can distribute as many lockboxes as you want, so that nobody can prevent its dissemination, and you can also guarantee the arrival of the combination to your friend, BUT you (and ONLY you) can prevent your friend from opening the lockboxes whenever you wish. Access to the safe no longer matters, because it doesn't provide access to the payload document.

#### Deadman's Gazette

The system proposed here is an implementation of the safe from that analogy, along with automatable instructions on how to set up, cancel, and defer a dead man's switch using the server. The server uses zero-access encryption and secure deletion to ensure that the originator of the dead man's switch retains complete control over if/when to release the payload.

## Whitepaper

### Deadman's Gazette Server

The server itself is a very basic set of authenticated API around a secured data store:

#### API

- `INSERT (passwordHash, encryptedDEK)`
    - `passwordHash` is the unique primary key and identifier, as well as the authentication
- `DELETE (passwordHash)`
    - securely deletes `encryptedDEK` record
- `GET (passwordHash) -> encryptedDEK`
- Public HTTPS: 
    - Serves a static page webapp to perform the client create/invalidate/delay actions described below 
    - Could also provide distribution of the public payload/packet data, directly to a blockchain or drop site
- Need API to support salting as well, for both the KEK and the password hash

#### Data Store
- [SQLCipher](https://github.com/sqlcipher/sqlcipher)
    - Provides encrypted data storage and secure deletion
    - Embedded in the server itself

#### Deployment
- Containerized API+DB
- Deployed as a Tor Hidden Service
    - [Hardened against DoS attacks](https://community.torproject.org/onion-services/advanced/dos/)
    - [Following Best Practices](https://riseup.net/en/security/network-security/tor/onionservices-best-practices)

### Creating a Dead Man's Switch

0. Choose a payload with which to create a dead man's switch. 
    - ðŸš¨ **At the end of the chosen time-lock expiration, and without action from the originator, this payload will be made public** ðŸš¨
1. Generate a strong encryption/decryption key pair for the payload 
    - This is the Data Encryption Key (DEK)
2. Generate a random plaintext password
    - THIS IS THE TOKEN THAT PROVIDES AUTHORIZATION FOR ALL FUTURE ACTIONS 
    - KEEP IT SECRET, KEEP IT SAFE
3. Use the password from Step 2 to encrypt the DEK from Step 1 
    - This is the Key Encryption Key (KEK)
    - Argon2 recommended, with server-provided salting
4. Deploy a Deadman's Gazette server (or use a trusted provider)
    - It's important that this server remain active for the duration of the expiration time length. It is therefore recommended that it be deployed secretly, resiliently, and securely, or that a trustworthy hosted service (i.e. one maintained by a reputable journalism outlet) is used.
    - This should be a tor hidden service - make note of the server's onion route for Step 7 below
5. Upload the hash of the plaintext password from Step 2 and the DEK from Step 3 to the Gazette server from Step 4
    - Hash using server-provided salting, different from that used to create the KEK
6. Use the DEK from Step 1 to encrypt the payload from Step 0
    - This can never been decrypted without the DEK from Step 1, which itself can only be decrypted using the password that generated the KEK from Step 2
    - At this point, nobody but the originator has access to the password, which means that until steps 7 and 8 are completed below, the payload can never be decrypted except by the originator
7. Time-lock encrypt the packet {plaintextPassword(Step 2), serverOnionRoute(Step 4)} using drand's tlock
    - Map the desired switch expiration time length to a drand round number and use that round's encryption key
8. Publish the encrypted payload from Step 6 and the time-locked packet from Step 7, as well as a Round Number for the decryption key from drand
    - Must be somewhere public and resilient (mirrored) so that it cannot be taken down, i.e. a publicly maintained drop site, or even a blockchain (if the payload is small enough)
    - It's important that the location is public, visible, and knowable to people who would be interested in performing the decryption after the time-lock
        - It's also important that the packet, payload and round number are all associated with each other visibly, to facilitate data recovery if/when desired
9. Discard ALL data generated in these steps, other than the password (and obviously the published payload/packet data)

### What happens next?

The drand network ensures that the packet cannot be decrypted before the expiration time. At that time, without action from the originator, the dead man's switch will activate:

1. The decryption key for the packet will be generated and distributed by drand
2. Using that decryption key, a watcher of your dead man's switch can decrypt the publicly-available packet and retrieve the password as well as the onion route to the Deadman's Gazette hosting your data
3. That person can then retrieve the encrypted payload key from the server, and decrypt it using the password-generated KEK
4. Finally, they can use the resulting DEK to decrypt the original, publicly-available payload
5. And that's it! The switch has achieved the desired result

### How to Deactivate/Reset the Switch

This system uses a breakable chain of decryptions to provide cancellation, which is otherwise not an inherent feature of drand time-locking. In order to prevent decryption at the end of the time-lock, the password must be rendered useless by securely deleting the encrypted DEK record from the server by passwordHash (**NOTE: this requires trust, see below***)

Once the record is deleted, the time-locked password is useless, and the encrypted DEK no longer exists to be decrypted. The dead man's switch has been effectively disabled.

To delay/reset the switch, simply repeat part of the process above before deletion:

1. GET the encrypted DEK by passwordHash from the server
    - Deletion of the original `(passwordHash, encryptedDEK)` record can happen any time after Step 1
2. Decrypt the DEK using the password-generated KEK
3. Generate a new random password and re-encrypt the DEK
4. Upload the new `(passwordHash, encryptedDEK)` to the server
5. Time-lock encrypt the new `{password, serverRoute}` packet using drand with the new expiry
6. Publish the new packet and round number and publicly associate them with the original payload.

### Security Model

#### Drand Security Limitations

From the [drand documentation](https://docs.drand.love/docs/timelock-encryption/#%EF%B8%8F-security-assumptions):

> - **Malicious Nodes:** If a threshold number of malicious nodes join the network, they could generate all future random values and decrypt future timelock ciphertexts. Our quicknet network started with 18 organizations running 22 nodes, minimizing this risk.
> - **Quantum Resistance:** Our cryptography does not use quantum-resistant algorithms. If you encrypt something for 1000 years and a viable quantum computer emerges, it could decrypt it. Currently, no widespread quantum-resistant schemes exist for threshold identity-based encryption (IBE) cryptography.
> - **Network Shutdown:** If the League of Entropy shuts down, members would delete their keys. This means ciphertexts created after the network's cessation would be un-decryptable until quantum computers can break them.

#### Chain of Decryptions

The breakable chain of decryptions can be visualized:

```
[drandTimelock] -> [password] -> [KEK] -> [DEK] -> [PAYLOAD]
```

The payload maintains it's original encryption using the DEK at all times, and decrypting the KEK using the drand time-locked password cannot be prevented once set in motion. The indirection of using a secondary encryption to secure the DEK allows the time-lock to be reset or canceled at the will of the originator, simply by breaking the chain of decryptions (by deleting the KEK-encrypted DEK) that ends with the DEK that can decrypt the payload.

#### *Where is Trust Necessary

The Deadman's Gazette server is the ONLY link of trust in this chain -- and it's important to understand what is being trusted, how it fits into this system, and how you can minimize or eliminate this trust entirely. 

The Gazette server uses SQLCipher as a database - this prevents any unauthorized person from reading data even if the DB files leaked, but it ALSO provides secure deletion to prevent even authorized persons (e.g. the Gazette hosts) from reading data once it has been deleted (see the [docs](https://discuss.zetetic.net/t/forensic-recovery-of-deleted-data/20)). 

This is important, because if a cancelled KEK is persisted without your knowledge, the payload CAN STILL be decrypted once the drand network publishes the decryption key for that KEK's password after expiry. The Deadman's Gazette server accepts a *salted hash* of the password as identity/auth, NOT the original password itself, meaning that the server is no more capable of decrypting the payload key than anyone else, until the time-lock decryption key is published by drand. Securely deleting the stored data BEFORE this happens ensures the chain of decryptions is broken irrevokably, and the payload cannot be decrypted, *even by the server that originally stored the data*. 

This server is provided open-source, in order to eliminate this trust boundary. You can be assured that the server deletes (and does not mirror/persist) the data as claimed simply by auditing the code to your satisfaction (or, of course, by trusting the security experts who do such things).

HOWEVER, USE OF THIS AS A HOSTED SERVICE COMES WITH AN IMPLICIT TRUST THAT THE DEPLOYED SERVER IS RUNNING THE AUDITED CODE, AND THUS THAT DATA IS BEING DELETED (AND NOT BEING MIRRORED/PERSISTED OTHERWISE) IN THE WAY IT CLAIMS TO BE. This cannot be guaranteed using any hosted service, though presumably many would be trustworthy. **For this reason, if you have any concerns about the trustworthiness of a hosted service, or are handling payloads too sensitive to tolerate any level of risk, it is best to verify and deploy your own service.**

The drand network is resilient against a certain number of malicious nodes (see the [docs](https://docs.drand.love/docs/security-model/)), which should keep the time-lock duration intact and prevent early decryption by curious, unauthorized parties. 

Publication of the payload and the packet should be done in such a way as to be resilient against coordinated effort to remove the data, ensuring it exists to be decrypted if/when desired. For small data payloads, distributed ledgers (blockchains) may be an effective mechanism for this.

Using onion services for the server provides effective security and anonymization, as well as a natural obfuscation of the server itself, thus precluding most likely attacks. A denial of service attack (e.g. using TorsHammer) could temporarily disable the server and thus prevent any action, but since the most likely goal of an adversary would be to prevent release of the payload, this attack would actually work against that interest. By denying the originator access to cancellation, a DoS attack (unless it is maintained and unmitigated indefinitely) serves only to prevent cancellation of the payload's release. Once the server becomes available again, the decryption chain will remain intact. 
